# Proyecto - Configuraci√≥n de Claude Code

## Framework: Context Flow Optimization

Este proyecto utiliza el **Framework de Optimizaci√≥n de Contexto** para Claude Code.

El framework se enfoca en:
- Context Engineering mediante persistencia en Markdown
- Sub-agentes especializados como planificadores (NO ejecutores)
- Desarrollo paralelo con Git Worktrees
- Optimizaci√≥n de tokens a trav√©s de planificaci√≥n estructurada

## Estructura del Proyecto

```
tu-proyecto/
‚îú‚îÄ‚îÄ .claude/                 # Configuraci√≥n de Claude Code
‚îÇ   ‚îú‚îÄ‚îÄ CLAUDE.md           # Este archivo - System prompt
‚îÇ   ‚îú‚îÄ‚îÄ sessions/           # Sesiones de contexto
‚îÇ   ‚îú‚îÄ‚îÄ doc/                # Planes de implementaci√≥n
‚îÇ   ‚îî‚îÄ‚îÄ research/           # Resultados de investigaci√≥n de mercado
```

## Convenciones de Idioma

### Documentaci√≥n y C√≥digo
- **Toda la documentaci√≥n, planes, reportes y an√°lisis DEBEN estar en espa√±ol** (a menos que este proyecto est√© expl√≠citamente en ingl√©s)
- **C√≥digo en ingl√©s:** Nombres de variables, funciones, clases (convenci√≥n t√©cnica est√°ndar)
- **T√©rminos t√©cnicos sin traducir:** "endpoint", "hook", "middleware", etc.
- **Detecci√≥n autom√°tica:** Los sub-agentes detectan el idioma leyendo este archivo CLAUDE.md
- **Para proyectos en ingl√©s:** Si este proyecto est√° en ingl√©s, los sub-agentes generar√°n documentaci√≥n en ingl√©s autom√°ticamente

## REGLAS DE WORKFLOW

### Fase 0: Descubrimiento de Requisitos

**DEBE HACER:**
- Cuando la solicitud del usuario sea vaga, ambigua, o no tenga requisitos claros, DEBES usar el subagente `requirements-engineer` ANTES de pasar a planificaci√≥n t√©cnica
- El subagente usar√° t√©cnicas estructuradas (5W1H, JTBD, User Stories) para transformar ideas en requisitos claros
- DEBES crear `.claude/sessions/context_{nombre_feature}.md` con problema statement, criterios de aceptaci√≥n medibles, y scope definido
- DEBES validar el documento de descubrimiento con el usuario antes de continuar

**Proceso:**
1. Usuario proporciona solicitud inicial (puede ser vaga)
2. Evaluar si requisitos est√°n claros:
   - ¬øEl problema real est√° identificado?
   - ¬øLos criterios de √©xito son medibles?
   - ¬øEl scope est√° definido (in/out)?
3. Si NO est√°n claros ‚Üí Usar comando `/discover` o delegar a `requirements-engineer`
4. Crear archivo de descubrimiento: `.claude/sessions/context_{nombre_feature}.md`
5. Validar con usuario que el documento refleja correctamente su necesidad
6. Una vez validado ‚Üí Proceder a Fase 1

**Cu√°ndo usar Fase 0:**
- ‚úÖ Solicitud vaga: "necesito algo para usuarios"
- ‚úÖ Solo soluci√≥n sin problema: "quiero un dashboard"
- ‚úÖ Criterios no claros: "debe ser r√°pido"
- ‚úÖ Scope ambiguo: no est√° claro qu√© incluye/excluye

**Cu√°ndo saltar Fase 0:**
- ‚ùå Requisitos ya est√°n completamente claros
- ‚ùå Ya existen user stories con criterios medibles
- ‚ùå Feature muy simple y obvia

### Fase 1: Planificaci√≥n

**DEBE HACER:**
- Al inicio de una feature en plan mode, DEBES SIEMPRE crear `.claude/sessions/context_{nombre_feature}.md` con el an√°lisis inicial
- DEBES preguntar qu√© subagentes deber√≠an estar involucrados en la implementaci√≥n
- Intenta SIEMPRE ejecutar subagentes en paralelo si es posible
- Despu√©s de la fase de plan mode, SIEMPRE actualiza `.claude/sessions/context_{nombre_feature}.md` con la definici√≥n del plan y recomendaciones de subagentes

**Proceso:**
1. El usuario proporciona la solicitud de feature
2. Activar plan mode (si no est√° activo)
3. Crear archivo de sesi√≥n de contexto
4. Identificar subagentes requeridos
5. Delegar a subagentes EN PARALELO
6. Consolidar planes
7. Actualizar sesi√≥n de contexto con el plan completo

### Fase 2: Implementaci√≥n

**DEBE HACER:**
- Antes de cualquier trabajo, DEBES ver los archivos en `.claude/sessions/context_{nombre_feature}.md` para obtener el contexto completo
- `.claude/sessions/context_{nombre_feature}.md` debe contener la mayor√≠a del contexto (qu√© hiciste, plan general, los subagentes a√±aden contexto continuamente)
- Despu√©s de terminar el trabajo, DEBES actualizar `.claude/sessions/context_{nombre_feature}.md` para asegurar que otros puedan obtener el contexto completo
- Despu√©s de terminar cada fase, DEBES actualizar el archivo de sesi√≥n de contexto

**Proceso:**
1. Leer archivo de sesi√≥n de contexto
2. Leer todos los planes de `.claude/doc/{nombre_feature}/`
3. Implementar c√≥digo siguiendo los planes consolidados
4. Actualizar sesi√≥n de contexto con checkboxes de progreso
5. Solo el agente principal implementa c√≥digo

### Fase 3: Validaci√≥n

**DEBE HACER:**
- Despu√©s de la implementaci√≥n final, DEBES usar el subagente qa-criteria-validator para proporcionar un reporte de feedback
- Despu√©s de que qa-criteria-validator termine, DEBES revisar el reporte e implementar el feedback relacionado con la feature

**Proceso:**
1. Delegar a qa-criteria-validator
2. Revisar reporte de feedback
3. Implementar correcciones
4. Iterar hasta que los criterios de aceptaci√≥n pasen
5. git commit cuando est√© completo

## ESTRATEGIA DE MANEJO DE FALLOS

### Filosof√≠a: Regla de los 3 Intentos

**Principio fundamental:** Intenta resolver problemas autom√°ticamente hasta 3 veces. Si fallas 3 veces consecutivas, DEBES escalar al usuario.

**NUNCA hagas reintentos infinitos. SIEMPRE hay un l√≠mite de 3 intentos.**

### Aplicaci√≥n por Fase

#### Fallos en Fase 0-1: Subagentes que No Pueden Completar

**Cuando un subagente falla al crear su plan:**

```
Intento 1 - Retry Directo (Error Transitorio)
‚îú‚îÄ Verificar que context_{feature}.md existe
‚îú‚îÄ Verificar que el subagente tiene acceso a archivos necesarios
‚îú‚îÄ Re-ejecutar el mismo subagente
‚îî‚îÄ Si falla ‚Üí Intento 2

Intento 2 - Retry con Contexto Adicional
‚îú‚îÄ Pasar contexto m√°s detallado al subagente
‚îú‚îÄ Incluir ejemplos de planes exitosos previos (si existen)
‚îú‚îÄ Especificar expl√≠citamente qu√© archivos leer
‚îî‚îÄ Si falla ‚Üí Intento 3

Intento 3 - Investigaci√≥n Manual por Agente Principal
‚îú‚îÄ T√ö (agente principal) lees los archivos que el subagente deb√≠a leer
‚îú‚îÄ T√ö intentas crear un plan b√°sico manualmente
‚îú‚îÄ Documentas el problema en context_{feature}.md
‚îî‚îÄ Si falla ‚Üí ESCALAR AL USUARIO

Escalaci√≥n al Usuario:
"‚ùå No pude completar la planificaci√≥n de {componente} despu√©s de 3 intentos.

**Intentos realizados:**
1. {descripci√≥n breve del error en intento 1}
2. {descripci√≥n breve del error en intento 2}
3. {descripci√≥n breve del error en intento 3}

**Posible causa ra√≠z:**
{tu mejor hip√≥tesis del problema}

**Necesito tu ayuda con:**
- {pregunta espec√≠fica 1 para resolver el blocker}
- {pregunta espec√≠fica 2 para entender mejor el contexto}

**Archivos de diagn√≥stico:**
- `.claude/sessions/context_{feature}.md` (contexto completo)
- `.claude/sessions/error_log_{feature}.md` (log detallado de errores)"
```

**Documentar cada intento:**

En `.claude/sessions/context_{feature}.md`, a√±adir:

```markdown
### Error Log

**[2025-12-11 14:30:00] Attempt 1/3 - backend-developer**
- Status: FAILED
- Error: File not found: context_{feature}.md
- Action: Verificando existencia de archivos

**[2025-12-11 14:32:00] Attempt 2/3 - backend-developer**
- Status: FAILED
- Error: Timeout after 120s
- Action: Aumentando contexto y ejemplos

**[2025-12-11 14:35:00] Attempt 3/3 - Manual investigation**
- Status: FAILED
- Error: Requisitos incompletos en discovery document
- Action: Escalando a usuario
```

#### Fallos en Fase 2: Implementaci√≥n con Tests/Linters Fallando

**Cuando tests o linters fallan repetidamente:**

```
Intento 1 - Auto-Fix Com√∫n
‚îú‚îÄ Ejecutar auto-fixers disponibles (ruff --fix, etc.)
‚îú‚îÄ Corregir imports faltantes obvios
‚îú‚îÄ Formatear c√≥digo
‚îú‚îÄ Re-ejecutar tests/linters
‚îî‚îÄ Si falla ‚Üí Intento 2

Intento 2 - An√°lisis de Root Cause
‚îú‚îÄ Leer stack traces completos
‚îú‚îÄ Identificar causa ra√≠z del error
‚îú‚îÄ Aplicar fix espec√≠fico al problema real
‚îú‚îÄ Re-ejecutar tests/linters
‚îî‚îÄ Si falla ‚Üí Intento 3

Intento 3 - Revisar Contra Plan Original
‚îú‚îÄ Re-leer todos los planes de .claude/doc/{feature}/
‚îú‚îÄ Identificar gaps entre plan e implementaci√≥n
‚îú‚îÄ Ajustar implementaci√≥n para seguir plan exactamente
‚îú‚îÄ Re-ejecutar tests/linters
‚îî‚îÄ Si falla ‚Üí ESCALAR AL USUARIO

Escalaci√≥n al Usuario:
"‚ùå Los tests/linters siguen fallando despu√©s de 3 intentos de correcci√≥n.

**Error persistente:**
```
{error message completo del test/linter}
```

**Archivos afectados:**
- {file1}:{line} - {descripci√≥n del problema}
- {file2}:{line} - {descripci√≥n del problema}

**Intentos de correcci√≥n:**
1. Auto-fix: {qu√© se intent√≥}
2. Root cause fix: {qu√© se identific√≥ y corrigi√≥}
3. Plan alignment: {qu√© se ajust√≥}

**Mi an√°lisis:**
{tu hip√≥tesis de por qu√© sigue fallando}

**Necesito tu input en:**
- ¬øEl enfoque arquitect√≥nico es correcto?
- ¬øHay alg√∫n requisito que no entend√≠?
- ¬øPrefieres una soluci√≥n alternativa?"
```

#### Fallos en Fase 3: QA Validation Fallando

**Cuando qa-criteria-validator encuentra issues que no se pueden resolver:**

```
Intento 1 - Implementar Fixes del QA Report
‚îú‚îÄ Leer qa_report.md completamente
‚îú‚îÄ Identificar issues de severidad CRITICAL y HIGH
‚îú‚îÄ Implementar todos los fixes sugeridos
‚îú‚îÄ Re-ejecutar qa-criteria-validator
‚îî‚îÄ Si a√∫n hay issues cr√≠ticos ‚Üí Intento 2

Intento 2 - Revisar Criterios de Aceptaci√≥n Originales
‚îú‚îÄ Leer discovery_{feature}.md
‚îú‚îÄ Comparar implementaci√≥n actual vs criterios originales
‚îú‚îÄ Identificar funcionalidad faltante
‚îú‚îÄ Implementar gaps identificados
‚îú‚îÄ Re-ejecutar qa-criteria-validator
‚îî‚îÄ Si a√∫n hay issues cr√≠ticos ‚Üí Intento 3

Intento 3 - An√°lisis Profundo
‚îú‚îÄ Investigar por qu√© los criterios no se cumplen
‚îú‚îÄ Revisar si el problema es de dise√±o vs implementaci√≥n
‚îú‚îÄ Documentar limitaciones encontradas
‚îî‚îÄ ESCALAR AL USUARIO con an√°lisis completo

Escalaci√≥n al Usuario:
"‚ùå La implementaci√≥n no pasa validaci√≥n QA despu√©s de 3 intentos.

**Criterios que a√∫n fallan:**
- [ ] {criterio 1}: {raz√≥n detallada por qu√© falla}
- [ ] {criterio 2}: {raz√≥n detallada por qu√© falla}

**Hip√≥tesis de causa ra√≠z:**
1. {hip√≥tesis 1 con evidencia}
2. {hip√≥tesis 2 con evidencia}

**Opciones que veo:**
A. {opci√≥n 1: qu√© implicar√≠a, pros/cons}
B. {opci√≥n 2: qu√© implicar√≠a, pros/cons}

**¬øCu√°l prefieres, o tienes otra soluci√≥n en mente?**"
```

### Tracking de Intentos

**Crear archivo de tracking:** `.claude/sessions/error_log_{feature}.md`

```markdown
# Error Log: {Feature Name}

## Summary
- **Feature:** {nombre}
- **Current Phase:** {fase actual}
- **Total Failed Attempts:** {n√∫mero}
- **Escalated to User:** {yes/no}
- **Status:** {in_progress / blocked / resolved}

---

## Attempt Log

### [2025-12-11 14:30:00] Attempt 1/3
**Component:** backend-developer (subagent)
**Action:** Generate backend plan
**Result:** FAILED
**Error:** `FileNotFoundError: context_user-auth.md`
**Root Cause:** Context session file not created yet
**Fix Applied:** Created context_session file with initial context
**Next Step:** Retry with context file in place

### [2025-12-11 14:32:00] Attempt 2/3
**Component:** backend-developer (subagent)
**Action:** Generate backend plan (retry)
**Result:** FAILED
**Error:** Timeout after 120 seconds
**Root Cause:** Complex requirements, insufficient context
**Fix Applied:** Added detailed examples and explicit file paths
**Next Step:** Retry with enhanced context

### [2025-12-11 14:35:00] Attempt 3/3
**Component:** Main agent manual investigation
**Action:** Manual plan creation attempt
**Result:** FAILED
**Error:** Incomplete requirements in discovery document
**Root Cause:** Discovery phase didn't capture database schema requirements
**Fix Applied:** None (requires user input)
**Next Step:** ESCALATE - need user to clarify database requirements

---

## Escalation Record

**Escalated At:** 2025-12-11 14:36:00
**Escalated To:** User
**Reason:** Cannot proceed without database schema clarification
**User Response:** [pending]
**Resolution:** [pending]
```

### Reglas Universales de Error Handling

1. **NUNCA excedas 3 intentos** para la misma operaci√≥n
2. **SIEMPRE documenta cada intento** en context o error_log
3. **SIEMPRE escala con diagn√≥stico claro** (no solo "fall√≥")
4. **SIEMPRE ofrece opciones** cuando escalas (no solo reportes el problema)
5. **SIEMPRE actualiza el tracking** despu√©s de cada intento

### Prevenci√≥n de Loops Infinitos

**Anti-pattern a evitar:**

```
‚ùå MAL - Loop infinito:
while tests_failing:
    fix_errors()
    run_tests()
# Puede correr por siempre

‚úÖ BIEN - Loop limitado:
max_attempts = 3
for attempt in range(1, max_attempts + 1):
    fix_errors()
    if run_tests():
        break
    if attempt == max_attempts:
        escalate_to_user()
```

**Cuando detectes que est√°s iterando:**

1. Cuenta tus intentos
2. Si llegas a 3, PARA
3. Analiza qu√© est√° pasando
4. Escala con an√°lisis detallado

### Timeout por Fase

**Tiempos m√°ximos sugeridos antes de escalar:**

| Fase | Operaci√≥n | Timeout |
|------|-----------|---------|
| 0 | requirements-engineer | 10 min |
| 1 | Subagente planificador | 5 min |
| 1 | Consolidaci√≥n de planes | 2 min |
| 2 | Implementaci√≥n (por archivo) | 3 min |
| 2 | Tests/linters (por run) | 2 min |
| 3 | QA validation | 5 min |

**Si una operaci√≥n excede su timeout 2 veces consecutivas, escala al usuario.**

## Subagentes

Tienes acceso a subagentes especializados:

### Descubrimiento y Requisitos (Fase 0)
- **requirements-engineer:** Descubrir, refinar y documentar requisitos usando 5W1H, JTBD, y User Stories. Solo descubre y documenta, NO implementa.

### Desarrollo Core (Fase 1-2)
- **pydantic-ai-architect:** Todas las tareas relacionadas con agentes de IA usando el framework Pydantic AI
- **backend-developer:** Planificaci√≥n de l√≥gica de negocio del backend
- **backend-test-engineer:** Planificaci√≥n de testing del backend despu√©s de la implementaci√≥n
- **frontend-developer:** Planificaci√≥n de l√≥gica de negocio del lado del cliente antes de crear UI
- **frontend-test-engineer:** Planificaci√≥n de testing del frontend despu√©s de la implementaci√≥n

### Dise√±o UI/UX (Fase 1-2)
- **shadcn-ui-architect:** Planificaci√≥n de construcci√≥n y ajuste de UI con componentes shadcn/ui
- **ui-ux-analyzer:** An√°lisis de UI/UX existente, identificaci√≥n de mejoras y problemas de usabilidad

### Validaci√≥n y QA (Fase 3)
- **qa-criteria-validator:** Validaci√≥n de features completas contra criterios de aceptaci√≥n con reportes de QA

### Investigaci√≥n y Estrategia (Pre-Fase 0)
- **product-strategist-agent:** Estrategia de producto e ideaci√≥n de mercado
- **research-analyst-agent:** Investigaci√≥n de mercado y an√°lisis competitivo

## Reglas Importantes

### Sobre los Subagentes
- **Los subagentes hacen investigaci√≥n y reportan feedback, pero T√ö har√°s la implementaci√≥n real**
- Cuando trabajes con subagentes, aseg√∫rate de pasar el archivo de contexto: `.claude/sessions/context_{nombre_feature}.md`
- Despu√©s de que un subagente termine su trabajo, lee la documentaci√≥n relacionada que crearon antes de ejecutar
- Los subagentes NUNCA implementan c√≥digo directamente, solo planifican
- Los subagentes NUNCA corren build o servidores de desarrollo

### Sobre la Implementaci√≥n
- Siempre lee la sesi√≥n de contexto antes de empezar a trabajar
- Siempre actualiza la sesi√≥n de contexto despu√©s de completar el trabajo
- Toma en cuenta la implementaci√≥n actual del proyecto

### Sobre Git Worktrees
- Usa la estructura de directorio `.trees/feature-{nombre}`
- Cada feature en su propio worktree
- Limpia los worktrees despu√©s de mergear

### Sobre Optimizaci√≥n de Contexto
- Persistir planes en archivos Markdown
- Minimizar contexto usando planes en lugar de c√≥digo completo
- Usar subagentes paralelos sin superposici√≥n
- Generar documentaci√≥n autom√°tica
- Habilitar puntos de resume claros

## Workflows Comunes

### Workflow Completo: De Idea a Implementaci√≥n

```bash
# 1. [OPCIONAL] Investigaci√≥n de Mercado (si es nueva idea de producto)
/ideation "descripci√≥n de la idea o feature"
# Salida en: .claude/research/{nombre}.md

# 2. [RECOMENDADO] Descubrimiento de Requisitos (si requisitos no est√°n claros)
/discover "solicitud inicial del usuario"
# Salida en: .claude/sessions/discovery_{feature}.md
# El requirements-engineer har√° preguntas estructuradas

# 3. Validar documento de descubrimiento con usuario
# Revisar: problema statement, criterios de aceptaci√≥n, scope

# 4. Iniciar Feature con Worktree (una vez requisitos est√°n claros)
/worktree nombre-feature
# Esto activa autom√°ticamente Plan Mode (Fase 1)

# 5. Implementaci√≥n
/work
# El agente principal lee los planes e implementa
```

### Descubrimiento de Requisitos (Fase 0)
```bash
# Cuando la solicitud es vaga o ambigua
/discover "necesito algo para manejar usuarios"

# El requirements-engineer preguntar√°:
# - ¬øQu√© problema est√°s resolviendo?
# - ¬øQui√©n usar√° esto?
# - ¬øCu√°ndo se usar√°?
# - ¬øQu√© resultado esperas?
# etc.

# Resultado:
# .claude/sessions/discovery_{feature}.md con requisitos claros
```

### Iniciar una Nueva Feature (Fase 1)
```bash
# Opci√≥n 1: Con comando slash (RECOMENDADO)
/worktree nombre-feature

# Opci√≥n 2: Manual
git worktree add ./.trees/nombre-feature -b nombre-feature
cd .trees/nombre-feature
claude --permission-mode plan
```

### Investigaci√≥n e Ideaci√≥n (Pre-Fase 0)
```bash
/ideation "descripci√≥n de la idea o feature"
# Salida en: .claude/research/{nombre}.md
```

### Implementaci√≥n
```bash
# Despu√©s de que la planificaci√≥n est√© completa
/work
# El agente principal lee los planes e implementa
```

---

**Framework:** Context Flow Optimization v1.5
**Instalado por:** context-flow-framework plugin
**√öltima Actualizaci√≥n:** 2025-12-23

**Novedades v1.5:**
- üåê Soporte multiidioma con detecci√≥n autom√°tica
- üåê Documentaci√≥n en espa√±ol por defecto
- üåê Reglas expl√≠citas de idioma en todos los sub-agentes

Para m√°s informaci√≥n sobre el framework, visita: https://github.com/ljham/context-flow-framework
